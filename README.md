# Talk topics

- **Accessibility** -- topics related to issues (blind, deaf, colour-blind, limited interactivity, etc.), learn more about the challenges people face to help build empathy and teach the 20% that can make 80% of the difference in supporting users with disabilities.
- **Backends as a service** are common for frontend engineers that don't have resources or experience to build a backend.
- **Client-side data stores** -- you need to persist data between sessions somehow.
- **Component and design systems** are growing in popularity with things like React Storybook, Atomic Design, and component oriented frameworks and primitives built into platforms themselves.
- **Concurrency** on the frontend. Why? Concurrency models (actors, CSP, etc...), how do we think about coordination mechanisms, and their costs? How do we use this view to evaluate design choices we make, and ones made by libraries/frameworks. What are the specific concurrency problems that we deal with on the frontend? Co-operative multi-tasking. Parallelism.
- **Data visualization** topics such as preparing data, choosing the right type of visualization, interactive visualizations, etc.
- **Graphics**: OpenGL/WebGL, ThreeJS, "Metal", etc.
- **Internationalization / localization** things to think about, and how to get there. From getext, build pipeline considerations, effects on your layout when things grow or shrink dramatically, RTL and LTR layouts.
- **Layout**: on the web we know flexbox, other platforms have their own layout systems. what are the ideas behind these and the tradeoffs of each?
- **Mobile computing and performance constrained computing** it’s easy to say that this must always be a consideration, and have hard to enforce policies that all code must be audited for this, but what can we do in an automate fashion to help catch this. Whether it’s design guidelines, linting, testing, etc...
- **New platforms**: user interfaces in VR, watches, augmented reality, cars, and the like.
- **Offline support**: from being offline for seconds (retries), to minutes (potential minor collisions), to hours / days (many collisions, complex conflict resolution). Each requires different levels of considerations in applications, what are they?
- **Operations on the frontend**: once your code is running on a client, we can’t really do too much. But what can we do to detect users are having issues that might be going unreported. Anywhere from often times we’ll have analytics (eg Google), crash reporting, update notification for mobile apps, etc... What other operations should we be concerned about, and how can we incorporate that into our applications?
- **Performance** explain performance from first principles eg: rendering pipelines. Tools and techniques to make UIs more responsive and smooth, eg: on the web, requestIdleCallback, requestAnimationFrame, avoiding doing work on the main thread where possible. WebAssembly for the web. How do you profile and improve performance? How do you measure it in production? How do you prevent regressions? Techniques to improve perceived performances eg: placeholder UI.
- **Routing & Navigation**: most applications have more than one "screen", so you need a way to go back and forth between them. Different platforms do this differently, what can we learn from each other? What are the core ideas behind routing and navigation that are everywhere?
- **Sharing code and knowledge across platforms**: Cordova, React Native, NativeScript, other JS solutions. C, C++.
- **State management** UIs are very complex state machines and problems faced on the front-end are very different from the backend, where quite often state lasts only the duration of a request. GraphQL, REST, JSON API, etc from the perspective of a frontend engineer, Redux, RxJS.  Mutation vs immutable data. Single source of truth vs decentralized state.
- **Static analysis** beyond type systems. For example: infer, prettier, linters, code coverage, code quality tools.
- **Styling applications**: in the small this isn’t a big deal, especially with various CSS frameworks that take much of the styling needs away from smaller scoped projects. But as the application grows, and so does it’s scope this part of the code grows rather quickly, and can become unwieldy. This is further compounded with various needs like keep page weight down, using classes for testing + styling
- **Type systems** are new to many people on the frontend, at the very least these allow the tool chain to find bugs for you, by book keeping some of the expectations one might have for various inputs and outputs of functions. For someone new to type systems they’re likely to think having a lot of ‘string’ and ‘integer’ checks all over their code might not help very much. How does one exploit a type system to actually model your domain, make it easier to reason, reduce bugs, and ease code reviews? What are popular type systems and how do they compare? Elm, ReasonML, TypeScript, Flow from the JS side, Kotlin on the Android, Swift on iOS and elsewhere.

- **Other**: so many other potential topics that we're missing, surely.
